# 数组

把数组列为数据结构的一种，你可能不适应，因为太熟悉了，和那些看起来难懂、写也不会写的数据结构相比，根本不是一类东西。

但其实，这只是一种错觉，那些东西你不熟，仅仅是因为见得少，用得少，多了也一样。

数组是一种存储元素的线性集合，元素可以通过索引来进行存取，然而，在javascript中，数组也是一种对象，它的索引在内部仍然被处理成字符串，就像对象的属性名那样，所以当我们使用”typeof 某数组“的时候，会显示object。

## 创建

```js
    var arr = [];   //字面量
    var arr = new Array();  //构造函数
```

几个tips：

一、数组元素不定类型，可以是任意类型，它仅仅是用来存储数据的容器，例如：
```js
    [2,"idea",true,null]
```
二、`[1,2,3]`和 `new Array(1,2,3)`效果一样，但`[3]`和`new Array(3)`就不一样了，后者会把单独的数字当做**数组长度**

三、可以不管原本数组`length`多少，直接访问`array[任意数字]`，也可以直接修改`length`的值，当然，只是不会报错，对数组本身是有影响的，访问原本没有的位置会填充`undefined`，修改的`length`要么将数组裁剪，要么增加新的`undefined`.

四、既然数组元素不定类型，那么它也可以是数组，就形成了二维数组，甚至多维数组，就像这样：

`[[1,2],[3,4]]`,我们想访问数字2，就是`[0][1]`

## 判断

有什么方法可以判断一个对象是数组，前面说了`typeof`做不到，那么还有两种简单的办法：

`arr instanceof Array` 和 `Array.isArray(arr)`

如果arr是数组，二者都会返回true。

## 用途

数组看起来是一种特定的数据形式，但用途十分广泛，甚至于说**”每个js文件当中都有数组“**都不为过。

为什么呢，因为其简单且常见的存储形式，能够对应很多场景的存取需要，二来，强大的方法体系。

**只要涉及列表的生成，增、删、改、查，都可以用到数组**。

## 方法

数组的方法有很多，很简单的就不说了，我们分类看看那些常用的方法。

### 增、删

`push()/pop()、unshift()/shift()`
```js
arr = [1,2,3];
//push()方法后面增加
arr.push(4);  // 修改后 [1,2,3,4];
//pop()方法后面删除
arr.pop();    // 修改后 [1,2,3];
```
这里有个细节，push()可以一次添加多个，push(4，5，6) // 修改后 [1,2,3,4,5,6];且返回的是数组的length。而pop()方法只能删除一个，返回删掉的那个元素。unshift()方法前面增加，shift()方法前面删除，效果和前两者相同，但方向相反，不再赘述。

但它们有一个不太好的地方，都需要将数组其他地方全部前移或者后移。

那么还有一些方法可以完成类似操作，且更灵活。

`splice()`

此方法需要几个参数：**起始位置、删除个数、添加元素**。

```js
var arr = [1,2,3,4];
arr.splice(3,0,"5,6,7,8");  // [1, 2, 3, "5,6,7,8", 4]

//我猜其实理想的效果是这样的—— [1, 2, 3, 5,6,7,8,4]，为什么成了上面那样？哥们，我们本来插入的就是一个字符串呀，你应该还记得数组的元素是不限定类型的，如果想要上面的效果，可以这样

arr.splice(3,0,5,6,7,8);   //[1,2,3,5,6,7,8,4];

//当然，你还可以插入数组
arr.splice(3,0,[5,6,7,8]) // [1,2,3,[5,6,7,8],4];

//甚至第三个参数省略，就成了删除元素
arr.splice(3,1)  // [1,2,3];
```

需要注意的是，有个方法跟它长得很像，容易搞混，语法是——`slice(start，end)`;
跟splice()一样是返回从原数组剪切出来的元素，但**它不会改变原数组**，也就没有添加元素一说了。

### 查询

- indexOf()

```js
    var nameList = ["张三","李四","王二"];
    var target1 = "张三";
    var target2 = "帅哥";
    nameList.indexOf(target1); //有，返回具体索引位置 0
    nameList.indexOf(target2); //没有，返回 -1
```

这是十分常见且被广泛使用的一种方法，它还有个兄弟是 lastIndexOf()，从后面开始检索，但如果数组里有多个，它们只会返回遇到的第一个元素的索引。

不过，ES6版本之后，又多了一种新的方法供使用，且表意更清晰，结果更直观。

- includes()

  以上面为例：

```js
  nameList.includes(target1); //有，true
  nameList.includes(target2); //没有，false
```

  这个方法用来判断”有没有“是要比上面方法更方便，但如果的确需要索引，还是可以使用上面方法。

### 生成

**数组转字符串**

`join()`

```js
var nameList = ["张三","李四","王二"];
nameList.join("和"); // "张三和李四和王二"
```

可以看出，join()方法就是使用它的参数(默认是逗号)，把数组的每一项连接起来，生成一个字符串，这就很强大了，你可以发挥想象，譬如：`"张三&&李四&&王二"`、`"2020-02-02"`,等等。

当然，还有个万能通用方法——`toString()`,基本什么遇到它都怪怪转字符串，除非此方法不可用，但相比之下就没有join()那么灵活了。

**字符串转数组**

`split()`

这个方法跟join()像是两个相反的过程，join()方法会提供一个用来连接字符的符号组成字符串，哪怕是空格，split()同样，需要有个分割的标志。

```js
var str = "张三 李四 王二";
str.split(" ");  // ["张三", "李四", "王二"]

var date = "2020-02-02";
date.split("-");  // ["2020", "02", "02"]
```

**连接数组**

`concat()`——连接两个数组

```js
    var firstStr = [1,2,3,4];
    var secondStr = [5,6,7,8];
    var resultStr = firstStr.concat(secondStr);  // [1, 2, 3, 4, 5, 6, 7, 8]
```

至此我们可以总结出：在对数组的操作当中，

### 迭代

遍历是个再常用不过的手段，你总会看到诸如这样的代码：

    var arr = [11,111,1111];
    for(var i = 0;i<=arr.length;i++){
        if(arr[i]>100){
            console.log(arr[i]); 
        }
    }
    // 输出 111和1111

当然，这里只是很简单的示例，实际上要比这个强大和灵活地多，但意思就是——**查看每个元素，符合某种条件的做一类操作，不符合的另做处理**。

上面使用的是最普遍的for循环，除此之外，还有其他遍历方法：

`forEach()`、`every()`、`some()`、`reduce()`、`map()` 和 `filter()`

下面逐一介绍：

`forEach()`——**函数作为参数，对数组的每一项执行同一操作**。

```js
function square(num) {
    console.log(num * num);
}
var nums = [1,2,3,4];
nums.forEach(square);  // 1,4,9,16
```
`every()`——**同样是函数作为参数，但返回值为布尔，只有在所有元素都执行为true，结果才为true**

```js
function isEven(num) {
    return num % 2 == 0;
}
var nums = [2,4,6,8,10];
var even = nums.every(isEven);
if (even) {
    console.log("都是偶数");
}
else {
    console.log("不都是偶数");
}
// 都是偶数
```
`some()`——**也接受一个返回值为布尔类型的函数，只要有一个元素使得该函数返回true，该方法就返回 true**。

不难理解，就不举例了..

`reduce()`——**从一个累加值开始，不断对结果和数组中的后续元素调用该函数，直到数组中的最后一个元素，返回得到的累加值。**

```js
function add(Total, curValue) {
    return Total + curValue;
}
var nums = [1,2,3,4,5,6,7,8,9,10]; 
var sum = nums.reduce(add);  // 55
```

注意，这个“累加值”并不局限于数字，因为“+”本身不局限于计算，还可以连接字符，所以，`reduce()`还可用于连接数组的所有字符串。

```js
function concat(string, item) {
    return string + item;
}
var words = ["我 ", "是 ","帅 ", "哥"];
var sentence = words.reduce(concat); // "我是帅哥"
```
`map()`——**和forEach()方法很相似，但它不是返回每次操作的值，而是返回一个新数组。**

```js
function addValue(i) {
    return i += 5;
}
var oldList = [77, 65, 81, 92, 83];
var newList = oldList.map(addValue); // [82, 70, 86, 97, 88]
```
`filter()`—“同every()方法类似，巡视整个数组所有元素，但它不返回布尔值，而是返回所有满足条件的元素组成的新数组。”

还拿上面那段代码举例：

```js
function isEven(num) {
    return num % 2 == 0;
}
var nums = [2,3,4,5,6,8,10];
var even = nums.filter(isEven); //  [2, 4, 6, 8, 10]
```
我新加了两个数（3，5）到数组中，可以看出，结果输出了一个新数组，并过滤掉了不满足条件的元素。

这个例子很简单，但如果你发挥自己的想象，就能实现很强大很有趣的功能，比如，找出所有同姓的，找出在某个范围的，等等。

### 排序

``reverse()``

这个方法虽然是数组的，但这个单词我们很常见，是反序的意思，指按照索引将数组反过来排列。

```js
var nums = [1,2,3,4,5];
nums.reverse(); // 5,4,3,2,1
```
当然，像删减操作一样，排序也有更强大的方法——`sort()`。

sort() 方法是按照字典顺序对元素进行排序的，即它假定元素都是字符串，当元素本身的确是字符串时，这当然没问题。

```js

var names = ["David","Mike","Cynthia","Clayton","Bryan","Raymond"];
names.sort();  // Bryan,Clayton,Cynthia,David,Mike,Raymond
```

但当元素是数字时，就会出问题，有解？当然，可以在调用方法时传入一个大小比较函数，排序时，sort() 方法将会根据该函数比较数组中两个元素的大小，从而决定整个数组的顺序。

该函数甚至可以是一个简单的相减操作，如果结果为负，那么被减数小于减数;如果结果为0，那么被减数与减数相等;如果结果为正，那么被减数大于减数。

```js
function compare(num1, num2) {
        return num1 - num2;
}
var nums = [3,1,2,100,4,200];
nums.sort(compare);  // 1,2,3,4,100,200
```
这里只是举了一个最简单的示例，实际情况则可以加入比较复杂的逻辑，根据结果的不同对数据进行排序，这里就不细说了。

### 去重

### 拷贝

**浅拷贝**

**深拷贝**